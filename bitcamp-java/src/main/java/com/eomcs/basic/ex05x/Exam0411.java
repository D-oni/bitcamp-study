package com.eomcs.basic.ex05x;

//# 비트 이동 연산자 : 비트 이동의 유효범위
//
public class Exam0411 {
  public static void main(String[] args) {
    System.out.println(3<<1);   //6
    //  000000000 00000000 00000000 00000011    = 3
    //  0|00000000 00000000 00000000 0000011x   =비트이동
    //     00000000 00000000 00000000 00000110  = 6

    System.out.println(3 << 33);    //6
    System.out.println(3 << 65);    //6 
    System.out.println(3 << 97);    //6

    //3에 33비트를 이동하나, 65비트를 이동하나, 97비트를 이동하나
    //같은 값이 나오는 이유?
    //=>int타입의 값에 대해 비트이동을 할 때는 0~31까지만 유효하다.
    //  만약 31을 넘는경우 32로 나눈 나머지 값을 비트 이동으로 간주한다.
    //=>long타입의 경우 비트이동은 0~63까지 유효하다.
    //  만약 63을 넘는 경우 64로 나눈 나머지 값을 비트이동으로 간주한다.

    //=>공식:
    //  n << s
    //  -n이 int 타입이라면, 다음 계산을 통해 s의 최종값을 결정한다. 
    //      s & 0b11111=최종 비트 이동 값
    //      따라서 s의 값은 무조건 0~31이다.
    //      결국 s의 값은 s % 32의 결과와 같다.
    //  -n이 long 타입이라면, 다음 계산을 통해 s의 최종값을 결정한다.
    //      s & 0b11111=최종 비트 이동 값
    //      따라서 s의 값은 무조건 0~63이다.
    //      결국 s의 값은 s % 64의 결과와 같다.
    //=>예1)
    //  n => 00000000 00000000 00000000 00000011 = 3
    //  s => 00000000 00000000 00000000 00010001 = 33 
    //  비트이동 => s & 0b1111
    //       00000000 00000000 00000000 00010001 = 33
    //     & 00000000 00000000 00000000 00010001 =
    //---------------------------------------------------
    //       00000000 00000000 00000000 00000001 = 1
    //  최종 비트 이동값을 계산하면 다음과 같다.
    //  3 << 33 == 3 << 1

    //=>예2)
    //  n => 00000000 00000000 00000000 00000011 = 3
    //  s => 00000000 00000000 00000000 01000001 = 65 
    //  비트이동 => s & 0b1111
    //       00000000 00000000 00000000 01000001 = 65
    //     & 00000000 00000000 00000000 00111111 =
    //---------------------------------------------------
    //       00000000 00000000 00000000 00000001 = 1 
    //  최종 비트 이동값을 계산하면 다음과 같다.
    //  3 << 65 == 3 << 1
    //
    //  비트 이동 계산의 근거
    //=>long데이터인 경우 비트 이동값은 하위 6비트만 유효하다.
  }
}





