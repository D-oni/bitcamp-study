package com.eomcs.basic.ex03;

//정수 리터럴(literal) -메모리 크기와 유효값 범위
//

public class Exam24 {
  public static void main(String[] args) {
    //23
    //=>0000 0000 0000 0000 0000 0000 0001 0111
    System.out.println(23);  
    //-23
    //1) sign-magitude
    //=>1000 0000 0000 0000 0000 0000 0001 0111
    //=>23+(-23)=0?
    // 0000 0000 0000 0000 0000 0000 0001 0111(23)
    //+1000 0000 0000 0000 0000 0000 0001 0111(-23)
    //-----------------------------------------
    // 1000 0000 0000 0000 0000 0000 0010 1110  = -46
    //이 방식은 23+(-23)=0의 결과가 옳게 나오지 않는다.
    //
    //2) 1's complement(1의 보수)
    //모든 비트를 1이되는 수로 바꾼다. 즉 0을 1로, 1을 0으로
    //=>1111 1111 1111 1111 1111 1111 1110 1000(-23)
    //23+(-23)
    // 0000 0000 0000 0000 0000 0000 0001 0111(23)
    //+1111 1111 1111 1111 1111 1111 1110 1000(-23) <=1의보수
    //----------------------------------------------
    // 1111 1111 1111 1111 1111 1111 1111 1111 =0이 아니다
    //+                                      1 <=1을 추가한다.
    //-----------------------------------------------
    // 10000 0000 0000 0000 0000 0000 0000 0000 =0
    //음수를 더할 때는 항상 결과에 1을 추가해야 한다.
    //
    //3) 2's complement(2의보수)
    //=>1의보수로 저장된 음수값을 더할 때 마다
    //  계산결과에 1을 추가하는 번거로움을 없애기 위해
    //  음수를 저장할 때 미리 1을 추가해 두는 방법
    //  1의보수 +1 => 2의보수
    // 0000 0000 0000 0000 0000 0000 0001 0111(23)
    //+1111 1111 1111 1111 1111 1111 1110 1001(-23) 
    //----------------------------------------------
    // 100000 0000 0000 0000 0000 0000 0000 0000 = 0
    //그래서 컴퓨터에서 음수를 메모리에 저장 할 때는 
    //양수와 음수를 더할때 정싱적인값이 나오도록
    //2의보수 방법으로 음수를 저장한다.
    System.out.println(-23);

    



    System.out.println(-23);

    
  }
}